<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SO(3): 3D Rotations &#8212; pytransform3d 3.6.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-sphinx.css?v=3b405b93" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css?v=7f9a90b1" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <script src="_static/documentation_options.js?v=5349f462"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="SE(3): 3D Transformations" href="transformations.html" />
    <link rel="prev" title="Introduction to 3D Rigid Transformations" href="introduction.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          pytransform3d</a>
        <span class="navbar-text navbar-version pull-left"><b>3.6.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="index.html">Contents</a></li>
                <li><a href="_auto_examples/index.html">Examples</a></li>
                <li><a href="api.html">API</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction to 3D Rigid Transformations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">SO(3): 3D Rotations</a></li>
<li class="toctree-l1"><a class="reference internal" href="transformations.html">SE(3): 3D Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="transformation_ambiguities.html">Transformation Ambiguities and Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="euler_angles.html">Euler Angles</a></li>
<li class="toctree-l1"><a class="reference internal" href="transformation_modeling.html">Modeling Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="transform_manager.html">Managing Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="transformation_over_time.html">Managing Transformations over Time</a></li>
<li class="toctree-l1"><a class="reference internal" href="camera.html">Camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="animations.html">Animations</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="_auto_examples/index.html">Examples</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">SO(3): 3D Rotations</a><ul>
<li><a class="reference internal" href="#rotation-matrix">Rotation Matrix</a></li>
<li><a class="reference internal" href="#axis-angle">Axis-Angle</a></li>
<li><a class="reference internal" href="#quaternions">Quaternions</a></li>
<li><a class="reference internal" href="#euler-angles">Euler Angles</a></li>
<li><a class="reference internal" href="#rotors">Rotors</a></li>
<li><a class="reference internal" href="#modified-rodrigues-parameters">Modified Rodrigues Parameters</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <section id="so-3-3d-rotations">
<h1>SO(3): 3D Rotations<a class="headerlink" href="#so-3-3d-rotations" title="Link to this heading">¶</a></h1>
<p>The group of all rotations in the 3D Cartesian space is called <img class="math" src="_images/math/f7f7fa0383c715b76a3ed7b029fd07e2f542451a.png" alt="SO(3)"/>
(SO: special orthogonal group). It is typically represented by 3D rotations
matrices. The minimum number of components that are required to describe
any rotation from <img class="math" src="_images/math/f7f7fa0383c715b76a3ed7b029fd07e2f542451a.png" alt="SO(3)"/> is 3. However, there is no representation that
is non-redundant, continuous, and free of singularities. We will now take a
closer look at competing representations of rotations and the orientations they
can describe.</p>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#rotation-matrix" id="id1">Rotation Matrix</a></p></li>
<li><p><a class="reference internal" href="#axis-angle" id="id2">Axis-Angle</a></p></li>
<li><p><a class="reference internal" href="#quaternions" id="id3">Quaternions</a></p></li>
<li><p><a class="reference internal" href="#euler-angles" id="id4">Euler Angles</a></p></li>
<li><p><a class="reference internal" href="#rotors" id="id5">Rotors</a></p></li>
<li><p><a class="reference internal" href="#modified-rodrigues-parameters" id="id6">Modified Rodrigues Parameters</a></p></li>
<li><p><a class="reference internal" href="#references" id="id7">References</a></p></li>
</ul>
</nav>
<p>Here is an overview of the representations and the conversions between them
that are available in pytransform3d.</p>
<a class="reference internal image-reference" href="_images/rotations.png"><img alt="Rotations" class="align-center" src="_images/rotations.png" style="width: 50%;" />
</a>
<p>Not all representations support all operations directly without conversion to
another representation. The following table is an overview. If the operation
is not implemented in pytransform3d then it is shown in brackets.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Representation</p></th>
<th class="head"><p>Inverse</p></th>
<th class="head"><p>Rotation of vector</p></th>
<th class="head"><p>Concatenation</p></th>
<th class="head"><p>Interpolation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Rotation matrix
<img class="math" src="_images/math/7580223f19f8adeaebf264954a214856067e3074.png" alt="\pmb{R}"/></p></td>
<td><p>Transpose</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>Compact axis-angle
<img class="math" src="_images/math/e053af6bf928b8c528cb031ebb9c37ab1b39abc3.png" alt="\pmb{\omega}"/></p></td>
<td><p>Negative</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>(Yes) <cite>(2)</cite></p></td>
</tr>
<tr class="row-even"><td><p>Axis-angle
<img class="math" src="_images/math/70583ffeb32a0843b74c661c2ffb65fd2fc0daa1.png" alt="(\hat{\pmb{\omega}}, \theta)"/></p></td>
<td><p>Negative axis</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>SLERP</p></td>
</tr>
<tr class="row-odd"><td><p>Logarithm of rotation
<img class="math" src="_images/math/0b9e14c5cc096d7fbff8198de5f08cb44ba42af5.png" alt="\left[\pmb{\omega}\right]"/></p></td>
<td><p>Negative</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>(Yes) <cite>(2)</cite></p></td>
</tr>
<tr class="row-even"><td><p>Quaternion
<img class="math" src="_images/math/4093d557bd0321bf32c1cd4263badce666a9d0e2.png" alt="\pmb{q}"/></p></td>
<td><p>Conjugate</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>SLERP</p></td>
</tr>
<tr class="row-odd"><td><p>Rotor
<img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/></p></td>
<td><p>Reverse</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>SLERP</p></td>
</tr>
<tr class="row-even"><td><p>Euler angles
<img class="math" src="_images/math/83c71b6e07feeb9e154a6ba4919e7e3455f0e5ed.png" alt="(\alpha, \beta, \gamma)"/></p></td>
<td><p><cite>(1)</cite></p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>Modified Rodrigues parameters
<img class="math" src="_images/math/b6c245d487949782a89cab9ee83504a62fdc2337.png" alt="\psi"/></p></td>
<td><p>Negative</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
</tbody>
</table>
<p>Footnotes:</p>
<p><cite>(1)</cite> Inversion of Euler angles in convention ABC (e.g., xyz) requires using
another convention CBA (e.g., zyx), reversing the order of angles, and taking
the negative of these.</p>
<p><cite>(2)</cite> Linear interpolation is approximately correct.</p>
<section id="rotation-matrix">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Rotation Matrix</a><a class="headerlink" href="#rotation-matrix" title="Link to this heading">¶</a></h2>
<p>One of the most practical representations of orientation is a rotation matrix</p>
<div class="math">
<p><img src="_images/math/568f736b80534f37b7a8fb3d2347612c55112281.png" alt="\boldsymbol R =
\left( \begin{array}{ccc}
    r_{11} &amp; r_{12} &amp; r_{13}\\
    r_{21} &amp; r_{22} &amp; r_{23}\\
    r_{31} &amp; r_{32} &amp; r_{33}\\
\end{array} \right)
\in SO(3)."/></p>
</div><p>Note that this is a non-minimal representation for orientations because we
have 9 values but only 3 degrees of freedom. This is because
<img class="math" src="_images/math/9b0478c944ec81bbf98d8cb2e9e8ff49466e1f9a.png" alt="\boldsymbol R"/> is orthonormal, which results in 6 constraints
(enforced with <a class="reference internal" href="_apidoc/pytransform3d.rotations.norm_matrix.html#pytransform3d.rotations.norm_matrix" title="pytransform3d.rotations.norm_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">norm_matrix()</span></code></a>):</p>
<ul class="simple">
<li><p>column vectors must have unit norm (3 constraints)</p></li>
<li><p>and must be orthogonal to each other (3 constraints)</p></li>
</ul>
<p>A more compact representation of these constraints is
<img class="math" src="_images/math/f5b207a9d7426a25542316e9023513a162fafd31.png" alt="\boldsymbol R^T \boldsymbol R = \boldsymbol I
\Leftrightarrow \boldsymbol R^T = \boldsymbol R^{-1}"/>.</p>
<p>In addition, <img class="math" src="_images/math/d303745231f0aa8b4bd3118061bfe93612f08596.png" alt="\det(\boldsymbol R) = 1"/> because we use right-handed
coordinate system (<img class="math" src="_images/math/ef05fe6f429d140e57f8fdf3919fccbe69e73ea0.png" alt="\det(\boldsymbol R) = -1"/> for left-handed
coordinate systems).</p>
<p>Hence, the group <img class="math" src="_images/math/f7f7fa0383c715b76a3ed7b029fd07e2f542451a.png" alt="SO(3)"/> is defined as</p>
<div class="math">
<p><img src="_images/math/2b59022847a4b423dedca3b2af1953c3374486e6.png" alt="SO(3) = \{\boldsymbol{R} \in \mathbb{R}^{3 \times 3} |
\boldsymbol{R}\boldsymbol{R}^T = \boldsymbol{I},
\det(\boldsymbol{R}) = 1\}."/></p>
</div><p>pytransform3d uses a numpy array of shape (3, 3) to represent rotation
matrices and typically we use the variable name R for a rotation matrix.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are two conventions on how to interpret rotations: active
or passive rotation. The standard in pytransform3d is an active rotation.</p>
</div>
<p>We can use a rotation matrix <img class="math" src="_images/math/9ea3b600d91c4a102e2079d6497113822460f9ed.png" alt="\boldsymbol R_{AB}"/> to transform a point
<img class="math" src="_images/math/66590f2c53625eb372136e2bf77aa724fc887458.png" alt="_B\boldsymbol{p}"/> from frame <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> to frame <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are two different conventions on how to use rotation matrices to
apply a rotation to a vector. We can either (pre-)multiply the rotation
matrix to a column vector from the left side or we can (post-)multiply it
to a row vector from the right side.
We will use the <strong>pre-multiplication</strong> convention.</p>
</div>
<p>This means that we rotate a point <img class="math" src="_images/math/66590f2c53625eb372136e2bf77aa724fc887458.png" alt="_B\boldsymbol{p}"/> by</p>
<div class="math">
<p><img src="_images/math/0f3ae92086aab9005716079bcccf60b90242d05d.png" alt="_A\boldsymbol{p} = \boldsymbol{R}_{ABB} \boldsymbol{p}"/></p>
</div><p>This is called <strong>linear map</strong>.</p>
<p>Note that using our index notation and conventions the second index of the
rotation matrix and the left index of the point have to be the same. The
rotation is applied incorrectly if this is not the case.</p>
<p>We can see that <em>each column</em> of such a rotation matrix is a basis vector
of frame <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> with respect to frame <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>.
We can plot the basis vectors of an orientation to visualize it.
Here, we can see orientation represented by the rotation matrix</p>
<div class="math">
<p><img src="_images/math/e91720d98dd90c99b186158afdbe8512b9ab1200.png" alt="\boldsymbol R =
\left( \begin{array}{ccc}
    1 &amp; 0 &amp; 0\\
    0 &amp; 1 &amp; 0\\
    0 &amp; 0 &amp; 1\\
\end{array} \right)"/></p>
</div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytransform3d.rotations</span> <span class="kn">import</span> <span class="n">plot_basis</span>
<span class="n">plot_basis</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="_images/rotations-1.png" class="plot-directive" src="_images/rotations-1.png" />
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When plotting basis vectors it is a convention to use red for the x-axis,
green for the y-axis and blue for the z-axis (RGB for xyz).</p>
</div>
<p>We can easily chain multiple rotations: we can apply the rotation defined
by <img class="math" src="_images/math/9ea3b600d91c4a102e2079d6497113822460f9ed.png" alt="\boldsymbol R_{AB}"/> after the rotation <img class="math" src="_images/math/479e6a49216f7964c117c7c6f20334a8789eb239.png" alt="\boldsymbol R_{BC}"/>
by applying the rotation</p>
<div class="math">
<p><img src="_images/math/7de16531e57ecf8c0349877fe60edba4e57fe79b.png" alt="\boldsymbol R_{AC} = \boldsymbol R_{AB} \boldsymbol R_{BC}."/></p>
</div><p>Note that again the indices have to align. Otherwise rotations are not applied
in the correct order.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are two different conventions on how to concatenate rotation
matrices. Suppose we have a rotation matrix <img class="math" src="_images/math/53cf7ab686c88dcddc7745cf2970c2b6de315c7a.png" alt="R_1"/> and another matrix
<img class="math" src="_images/math/f59def0e720f7de8ca2abe4eb16528d1e9b9f3bf.png" alt="R_2"/> and we want to first rotate by <img class="math" src="_images/math/53cf7ab686c88dcddc7745cf2970c2b6de315c7a.png" alt="R_1"/> and then by
<img class="math" src="_images/math/f59def0e720f7de8ca2abe4eb16528d1e9b9f3bf.png" alt="R_2"/>. If we want to apply both rotations in global coordinates, we
have to concatenate them with <img class="math" src="_images/math/5db82d008f7b95daf144bfc3a194f4852765e8fb.png" alt="R_2 \cdot R_1"/>. We can also express
the second rotation in terms of a local, body-fixed coordinates by
<img class="math" src="_images/math/095df9aa7aeebaf66725086d98973784d835f83e.png" alt="R_1 \cdot R_2"/>, which means <img class="math" src="_images/math/53cf7ab686c88dcddc7745cf2970c2b6de315c7a.png" alt="R_1"/> defines new coordinates in
which <img class="math" src="_images/math/f59def0e720f7de8ca2abe4eb16528d1e9b9f3bf.png" alt="R_2"/> is applied. Note that this applies to both
passive and active rotation matrices.</p>
</div>
<p>The easiest way to construct rotation matrices is through rotations about the
basis vectors with <a class="reference internal" href="_apidoc/pytransform3d.rotations.active_matrix_from_angle.html#pytransform3d.rotations.active_matrix_from_angle" title="pytransform3d.rotations.active_matrix_from_angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">active_matrix_from_angle()</span></code></a>.
Multiple rotation matrices that were constructed like this can be concatenated.
This will be done, for instance, to obtain rotation matrices from Euler angles
(see <a class="reference internal" href="euler_angles.html"><span class="doc">Euler Angles</span></a>).</p>
<p><strong>Pros</strong></p>
<ul class="simple">
<li><p>It is easy to apply rotations on point vectors by matrix-vector
multiplication.</p></li>
<li><p>Concatenation of rotations is trivial through matrix multiplication.</p></li>
<li><p>You can directly read the basis vectors from the columns.</p></li>
<li><p>No singularities.</p></li>
</ul>
<p><strong>Cons</strong></p>
<ul class="simple">
<li><p>We use 9 values for 3 degrees of freedom.</p></li>
<li><p>Not every 3x3 matrix is a valid rotation matrix, which means for example
that we cannot simply apply an optimization algorithm to rotation matrices
or interpolate between rotation matrices. Renormalization is
computationally expensive in comparison to quaternions.</p></li>
</ul>
</section>
<section id="axis-angle">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Axis-Angle</a><a class="headerlink" href="#axis-angle" title="Link to this heading">¶</a></h2>
<figure class="align-default">
<img alt="_images/plot_axis_angle.png" class="plot-directive" src="_images/plot_axis_angle.png" />
</figure>
<p>Each rotation can be represented by a single rotation around one axis.
The axis can be represented as a three-dimensional unit vector and the angle
by a scalar:</p>
<div class="math">
<p><img src="_images/math/e8e73e5cb22e0fb7685152346668ff54acb27b5a.png" alt="\left( \hat{\boldsymbol{\omega}}, \theta \right) = \left( \left( \begin{array}{c}\omega_x\\\omega_y\\\omega_z\end{array} \right), \theta \right)"/></p>
</div><p>pytransform3d uses a numpy array of shape (4,) for the axis-angle
representation of a rotation, where the first 3 entries correspond to the
unit axis of rotation and the fourth entry to the rotation angle in
radians, and typically we use the variable name a.</p>
<p>Note that the axis-angle representation has a singularity at
<img class="math" src="_images/math/109ffdd25f4d03b396550bcee7b0a44b1d1ae8a6.png" alt="\theta = 0"/> as there is an infinite number of rotation axes that
represent the identity rotation in this case. However, we can modify the
representation to avoid this singularity.</p>
<p>It is possible to write this in a more compact way as a rotation vector:</p>
<div class="math">
<p><img src="_images/math/60b7a7ea3c1d4d9145e0af4abdea517ab30d9090.png" alt="\boldsymbol{\omega} = \hat{\boldsymbol{\omega}} \theta \in \mathbb{R}^3"/></p>
</div><p>pytransform3d uses a numpy array of shape (3,) for the compact axis-angle
representation of a rotation and typically we use the variable name a.</p>
<p>We can also refer to this representation as <strong>exponential coordinates of
rotation</strong>. We can easily represent angular velocity as
<img class="math" src="_images/math/c43c330a71600e506e90a2c5ebc290ff588dd510.png" alt="\hat{\boldsymbol{\omega}} \dot{\theta}"/>
and angular acceleration as
<img class="math" src="_images/math/20931b130d9b0a8d6fde584a22bec352f2fa9f8b.png" alt="\hat{\boldsymbol{\omega}} \ddot{\theta}"/> so that we can easily do
component-wise integration and differentiation with this representation.
In addition, we can represent <img class="math" src="_images/math/a6ad2947566b056c289bcb03a106d6f4e03ad208.png" alt="\hat{\boldsymbol{\omega}} \theta"/> by
the cross-product matrix</p>
<div class="math">
<p><img src="_images/math/178feb0b77e77bf67df073966ca2d50b8814401e.png" alt="\left[\hat{\boldsymbol{\omega}}\right] \theta
=
\left(
\begin{matrix}
0 &amp; -\omega_3 &amp; \omega_2\\
\omega_3 &amp; 0 &amp; -\omega_1\\
-\omega_2 &amp; \omega_1 &amp; 0\\
\end{matrix}
\right)
\theta
\in so(3)
\subset \mathbb{R}^{3 \times 3},"/></p>
</div><p>where <img class="math" src="_images/math/df885cda063aa71320c69bb2645e3d4f76c950c4.png" alt="\left[\hat{\boldsymbol{\omega}}\right] \theta"/> is the matrix
logarithm of a rotation matrix and <img class="math" src="_images/math/a0a12b77916dc9989ba20b36a182b3f90fdc3549.png" alt="so(3)"/> is the Lie algebra of
the Lie group <img class="math" src="_images/math/f7f7fa0383c715b76a3ed7b029fd07e2f542451a.png" alt="SO(3)"/>.</p>
<p><strong>Pros</strong></p>
<ul class="simple">
<li><p>Minimal representation (as rotation vector, also referred to as compact
axis-angle in the code).</p></li>
<li><p>Can also represent angular velocity and acceleration when we replace
<img class="math" src="_images/math/8a87f04e7d7cca18343c084cceca5237fae62491.png" alt="\theta"/> by <img class="math" src="_images/math/156be057a637fe3140b40c304b4c9a44631b057b.png" alt="\dot{\theta}"/> or <img class="math" src="_images/math/96b8f8a8da08691f9653aa25764e645178573334.png" alt="\ddot{\theta}"/> respectively,
which makes numerical integration and differentiation easy.</p></li>
</ul>
<p><strong>Cons</strong></p>
<ul class="simple">
<li><p>There might be discontinuities during interpolation as an angle of 0 and
any multiple of <img class="math" src="_images/math/2ef04e0a4bcc5f1840308dabe353cfe6e48632c4.png" alt="2\pi"/> represent the same orientation. This has to
be considered. Normalization is recommended.</p></li>
<li><p>When <img class="math" src="_images/math/1184d7371127cddc7d82dacb13faacc5959d91e0.png" alt="\theta = \pi"/>, the axes <img class="math" src="_images/math/a23fb3f80862b2cb49da5ab4d61c5a70147a0bd5.png" alt="\hat{\boldsymbol{\omega}}"/> and
<img class="math" src="_images/math/d3082e87b8052a94c2c358f31c7f86a358c35541.png" alt="-\hat{\boldsymbol{\omega}}"/> represent the same rotation, which is
a problem for interpolation.</p></li>
<li><p>Concatenation and transformation of vectors requires conversion to rotation
matrix or quaternion.</p></li>
</ul>
</section>
<section id="quaternions">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Quaternions</a><a class="headerlink" href="#quaternions" title="Link to this heading">¶</a></h2>
<p>Quaternions are represented by a scalar / real part <img class="math" src="_images/math/cc87ee665749db882f94e0d3707eb23e39638650.png" alt="w"/>
and an vector / imaginary part
<img class="math" src="_images/math/296b7098a4e3f5fcb52474893f620ff2889fb5b6.png" alt="x \boldsymbol{i} + y \boldsymbol{j} + z \boldsymbol{k}"/>.</p>
<div class="math">
<p><img src="_images/math/e3f513b07417b4c10ce6e996d5d02d939e90d74b.png" alt="\boldsymbol{q} = w + x \boldsymbol{i} + y \boldsymbol{j} + z \boldsymbol{k}
\in \mathbb{H}"/></p>
</div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are two different quaternion conventions: Hamilton’s convention
defines <img class="math" src="_images/math/64e011788d9a16919f70050b9abb41dd0d11b27a.png" alt="ijk = -1"/> and the Shuster or JPL convention (from NASA’s
Jet Propulsion Laboratory, JPL) defines <img class="math" src="_images/math/0e435392bb9407c662458c942eabdc96786b4a87.png" alt="ijk = 1"/>.
These two conventions result in different multiplication operations and
conversions to other representations. We use Hamilton’s convention.</p>
</div>
<p>Read <a class="reference external" href="https://arxiv.org/pdf/1801.07478.pdf">this paper</a> for details about
the two conventions and why Hamilton’s convention should be used. Section VI A
gives further useful hints to identify which convention is used.</p>
<p>The unit quaternion space <img class="math" src="_images/math/20a10c99b80293d7cbbda09574a139e3fc9093a1.png" alt="\mathbb{S}^3"/> can be used to represent
orientations with an encoding based on the rotation axis and angle.
A rotation quaternion is a four-dimensional unit vector (versor)
<img class="math" src="_images/math/ccac8697bdb80904a21d231b0f7103543f8001f2.png" alt="\boldsymbol{\hat{q}}"/>.
The following equation describes its relation to axis-axis notation.</p>
<div class="math">
<p><img src="_images/math/201fe0f29a7365f64739614fd8f205a07399e735.png" alt="\boldsymbol{\hat{q}} =
\left( \begin{array}{c} w\\ x\\ y\\ z\\ \end{array} \right) =
\left( \begin{array}{c}
    \cos \frac{\theta}{2}\\
    \omega_x \sin \frac{\theta}{2}\\
    \omega_y \sin \frac{\theta}{2}\\
    \omega_z \sin \frac{\theta}{2}\\
\end{array} \right)
=
\left( \begin{array}{c}
    \cos \frac{\theta}{2}\\
    \hat{\boldsymbol{\omega}} \sin \frac{\theta}{2}\\
\end{array} \right)"/></p>
</div><p>pytransform3d uses a numpy array of shape (4,) for quaternions and
typically we use the variable name q.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The scalar component <img class="math" src="_images/math/cc87ee665749db882f94e0d3707eb23e39638650.png" alt="w"/> of a quaternion is sometimes the first
element and sometimes the last element of the versor. We will use
the first element to store the scalar component.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <em>antipodal</em> unit quaternions <img class="math" src="_images/math/ccac8697bdb80904a21d231b0f7103543f8001f2.png" alt="\boldsymbol{\hat{q}}"/> and
<img class="math" src="_images/math/86225c865643a22807d20c325823a7d08846f8b6.png" alt="-\boldsymbol{\hat{q}}"/> represent the same rotation (double cover).</p>
</div>
<p><strong>Pros</strong></p>
<ul class="simple">
<li><p>More compact than the matrix representation and less susceptible to
round-off errors.</p></li>
<li><p>The quaternion elements vary continuously over the unit sphere in
<img class="math" src="_images/math/1963e1d8fcb281cbc6b8edecfb23c75fd27f06e8.png" alt="\mathbb{R}^4"/> as the orientation changes, avoiding discontinuous
jumps (inherent to three-dimensional parameterizations).</p></li>
<li><p>Expression of the rotation matrix in terms of quaternion parameters
involves no trigonometric functions.</p></li>
<li><p>Concatenation is simple and computationally cheaper with the quaternion
product than with rotation matrices.</p></li>
<li><p>No singularities.</p></li>
<li><p>Renormalization is cheap in comparison to rotation matrices: we only
have to divide by the norm of the quaternion.</p></li>
</ul>
<p><strong>Cons</strong></p>
<ul class="simple">
<li><p>The representation is not straightforward to interpret.</p></li>
<li><p>There are always two unit quaternions that represent exactly the same
rotation.</p></li>
</ul>
</section>
<section id="euler-angles">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Euler Angles</a><a class="headerlink" href="#euler-angles" title="Link to this heading">¶</a></h2>
<p>A complete rotation can be split into three rotations around basis vectors.
pytransform3d uses a numpy array of shape (3,) for Euler angles, where
each entry corresponds to a rotation angle in radians around one basis
vector. The basis vector that will be used and the order of rotation
is defined by the convention that we use. See <a class="reference internal" href="euler_angles.html"><span class="doc">Euler Angles</span></a> for more
information.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are 24 different conventions for defining euler angles. There are
12 different valid ways to sequence rotation axes that can be interpreted
as extrinsic or intrinsic rotations: XZX, XYX, YXY, YZY, ZYZ, ZXZ, XZY,
XYZ, YXZ, YZX, ZYX, and ZXY.</p>
</div>
<p><strong>Pros</strong></p>
<ul class="simple">
<li><p>Minimal representation.</p></li>
<li><p>Euler angles are easy to interpret for users (when the convention is clearly
defined) in comparison to axis-angle or quaternions.</p></li>
</ul>
<p><strong>Cons</strong></p>
<ul class="simple">
<li><p>24 different conventions.</p></li>
<li><p>Singularities (gimbal lock).</p></li>
<li><p>Concatenation and transformation of vectors requires conversion to rotation
matrix or quaternion.</p></li>
</ul>
</section>
<section id="rotors">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Rotors</a><a class="headerlink" href="#rotors" title="Link to this heading">¶</a></h2>
<figure class="align-default">
<img alt="_images/plot_bivector.png" class="plot-directive" src="_images/plot_bivector.png" />
</figure>
<p>Rotors and quaternions are very similar concepts in 3D. However, rotors are
more general as they can be extended to more dimensions.</p>
<p>The concept of a quaternion builds on the axis-angle representation, in
which we rotate by an angle about a rotation axis (see black arrow in the
illustration above). The axis can be computed from the cross product of two
vectors (gray arrow). A rotor builds on a plane-angle representation, in which
we rotate with a given direction by an angle in a plane (indicated by gray
area). The plane can be computed from the wedge product <img class="math" src="_images/math/d2d6a29781c70c0393b37d240c9d44075cf0280c.png" alt="a \wedge b"/> of
two vectors <img class="math" src="_images/math/b3e65e3b6408fcfa00452530b73f55d1755f9965.png" alt="a"/> and <img class="math" src="_images/math/68c7c8c65602677ab56cf7fd88002023f0edc575.png" alt="b"/>, which is a so-called bivector. Although
both approaches might seem different, in 3D they operate with exactly the same
numbers in exactly the same way.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The rotors <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> and <img class="math" src="_images/math/c5a3dec6485499140b9ae2662bb4394e68a6ffe6.png" alt="-R"/> represent exactly the same rotation.</p>
</div>
<p>A rotor is a unit multivector</p>
<div class="math">
<p><img src="_images/math/d60c5bf605615cb1044f9657fb36d7e6e3a98ae7.png" alt="R = (a, b_{yz}, b_{zx}, b_{xy})"/></p>
</div><p>that consists of a scalar <img class="math" src="_images/math/b3e65e3b6408fcfa00452530b73f55d1755f9965.png" alt="a"/> and a bivector
<img class="math" src="_images/math/132dab5bff8b770be7a6d3bf0a3ae7bedd01fa4f.png" alt="(b_{yz}, b_{zx}, b_{xy})"/>. The components of a bivector constructed
by the wedge product of two vectors can be interpreted as the area of the
parallelogram formed by the two vectors projected on the three basis planes
yz, zx, and xy (see illustration above). These values also correspond to the
x-, y-, and z-components of the cross product of the two vectors, which allows
two different interpretations of the same numbers from which we can then derive
quaternions on the one hand and rotors on the other hand.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In pytransform3d our convention is that we organize the components of a
rotor in exactly the same way as we organize the components of the
equivalent quaternion. There are other conventions. It is not just possible
to change the order of the scalar and the bivector (similar to a
quaterion), but also to change the order of bivector components.</p>
</div>
<p>Pros and cons for rotors are the same as for quaternions as they have the
same representation in 3D.</p>
</section>
<section id="modified-rodrigues-parameters">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Modified Rodrigues Parameters</a><a class="headerlink" href="#modified-rodrigues-parameters" title="Link to this heading">¶</a></h2>
<p>Another minimal representation of rotation are modified Rodrigues parameters
(MRP)</p>
<div class="math">
<p><img src="_images/math/e7137004118a8a21cf9244b0fe7445c9ed73bbb8.png" alt="\psi = \tan \left(\frac{\theta}{4}\right) \hat{\boldsymbol{\omega}}"/></p>
</div><p>This representation is similar to the compact axis-angle representation.
However, the angle of rotation is converted to <img class="math" src="_images/math/e8cae6838446034c1a454be5089c423e2707e0f3.png" alt="\tan(\frac{\theta}{4})"/>.
Hence, there is an easy conversion from unit quaternions to MRP:</p>
<div class="math">
<p><img src="_images/math/d8bbd17ea079fc2a04447ecf2db01f51823ab96e.png" alt="\psi = \frac{\left( \begin{array}{c} x\\ y\\ z\\ \end{array} \right)}{1 + w}."/></p>
</div><p>given some quaternion with a scalar <img class="math" src="_images/math/cc87ee665749db882f94e0d3707eb23e39638650.png" alt="w"/> and a vector
<img class="math" src="_images/math/e38004e3e43e7141c97dadcee83d167236f6bbfe.png" alt="\left(x, y, z \right)^T"/>.</p>
<p>pytransform3d uses a numpy array of shape (3,) for modified Rodrigues
parameters.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>MRPs have a singuarity at <img class="math" src="_images/math/bf4d6dded1f2769dd9942a7e0071045945dbeb9a.png" alt="2 \pi"/> which we can avoid by ensuring the
angle of rotation does not exceed <img class="math" src="_images/math/9cc8517129c87252edd7fe2e4532af9dcf7a54d9.png" alt="\pi"/>.</p>
</div>
<p><strong>Pros</strong></p>
<ul class="simple">
<li><p>Minimal representation.</p></li>
</ul>
<p><strong>Cons</strong></p>
<ul class="simple">
<li><p>The representation is not straightforward to interpret.</p></li>
<li><p>Normalization of angle required to avoid singularity.</p></li>
<li><p>Concatenation and transformation of vectors requires conversion to rotation
matrix or quaternion.</p></li>
</ul>
</section>
<section id="references">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">References</a><a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>Why and How to Avoid the Flipped Quaternion Multiplication: <a class="reference external" href="https://arxiv.org/pdf/1801.07478.pdf">https://arxiv.org/pdf/1801.07478.pdf</a></p></li>
<li><p>Kindr cheat sheet: <a class="reference external" href="https://docs.leggedrobotics.com/kindr/cheatsheet_latest.pdf">https://docs.leggedrobotics.com/kindr/cheatsheet_latest.pdf</a></p></li>
<li><p>Let’s remove Quaternions from every 3D Engine: <a class="reference external" href="https://marctenbosch.com/quaternions/">https://marctenbosch.com/quaternions/</a></p></li>
<li><p>Applications of Geometric Algebra: <a class="reference external" href="http://geometry.mrao.cam.ac.uk/wp-content/uploads/2015/02/01ApplicationsI.pdf">http://geometry.mrao.cam.ac.uk/wp-content/uploads/2015/02/01ApplicationsI.pdf</a></p></li>
<li><p>Euler–Rodrigues formula variations, quaternion conjugation and intrinsic connections: <a class="reference external" href="https://doi.org/10.1016/j.mechmachtheory.2015.03.004">https://doi.org/10.1016/j.mechmachtheory.2015.03.004</a></p></li>
<li><p>Terzakis, Lourakis, Alt-Boudaoud: Modified Rodrigues Parameters: An Efficient Representation of Orientation in 3D Vision and Graphics, <a class="reference external" href="https://link.springer.com/article/10.1007/s10851-017-0765-x">https://link.springer.com/article/10.1007/s10851-017-0765-x</a></p></li>
<li><p>Hauser, Kris: Robotic Systems (draft), <a class="reference external" href="http://motion.pratt.duke.edu/RoboticSystems/3DRotations.html">http://motion.pratt.duke.edu/RoboticSystems/3DRotations.html</a></p></li>
</ol>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014-2024, Alexander Fabisch, DFKI GmbH, Robotics Innovation Center.<br/>
      Last updated on Sep 10, 2024.<br/>
    </p>
  </div>
</footer>
  </body>
</html>