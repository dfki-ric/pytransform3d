<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SO(3): 3D Rotations &#8212; pytransform3d 1.14.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="SE(3): 3D Transformations" href="transformations.html" />
    <link rel="prev" title="Notation" href="notation.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          pytransform3d</a>
        <span class="navbar-text navbar-version pull-left"><b>1.14.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="index.html">Contents</a></li>
                <li><a href="_auto_examples/index.html">Examples</a></li>
                <li><a href="api.html">API</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">SO(3): 3D Rotations</a></li>
<li class="toctree-l1"><a class="reference internal" href="transformations.html">SE(3): 3D Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="transformation_ambiguities.html">Transformation Ambiguities and Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="euler_angles.html">Euler Angles</a></li>
<li class="toctree-l1"><a class="reference internal" href="transformation_modeling.html">Modeling Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="transform_manager.html">Managing Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="camera.html">Camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="animations.html">Animations</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="_auto_examples/index.html">Examples</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">SO(3): 3D Rotations</a><ul>
<li><a class="reference internal" href="#rotation-matrix">Rotation Matrix</a></li>
<li><a class="reference internal" href="#axis-angle">Axis-Angle</a></li>
<li><a class="reference internal" href="#quaternions">Quaternions</a></li>
<li><a class="reference internal" href="#euler-angles">Euler Angles</a></li>
<li><a class="reference internal" href="#rotors">Rotors</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="so-3-3d-rotations">
<h1>SO(3): 3D Rotations<a class="headerlink" href="#so-3-3d-rotations" title="Permalink to this heading">¶</a></h1>
<p>The group of all rotations in the 3D Cartesian space is called <img class="math" src="_images/math/f7f7fa0383c715b76a3ed7b029fd07e2f542451a.png" alt="SO(3)"/>
(SO: special orthogonal group). It is typically represented by 3D rotations
matrices. The minimum number of components that are required to describe
any rotation from <img class="math" src="_images/math/f7f7fa0383c715b76a3ed7b029fd07e2f542451a.png" alt="SO(3)"/> is 3. However, there is no representation that
is non-redundant, continuous, and free of singularities. We will now take a
closer look at competing representations of rotations and the orientations they
can describe.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#rotation-matrix" id="id1">Rotation Matrix</a></p></li>
<li><p><a class="reference internal" href="#axis-angle" id="id2">Axis-Angle</a></p></li>
<li><p><a class="reference internal" href="#quaternions" id="id3">Quaternions</a></p></li>
<li><p><a class="reference internal" href="#euler-angles" id="id4">Euler Angles</a></p></li>
<li><p><a class="reference internal" href="#rotors" id="id5">Rotors</a></p></li>
<li><p><a class="reference internal" href="#references" id="id6">References</a></p></li>
</ul>
</div>
<p>Here is an overview of the representations and the conversions between them
that are available in pytransform3d.</p>
<a class="reference internal image-reference" href="_images/rotations.png"><img alt="Rotations" class="align-center" src="_images/rotations.png" style="width: 50%;" /></a>
<p>Not all representations support all operations directly without conversion to
another representation. The following table is an overview. If the operation
is not implemented in pytransform3d then it is shown in brackets.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 14%" />
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Representation</p></th>
<th class="head"><p>Inverse</p></th>
<th class="head"><p>Rotation of vector</p></th>
<th class="head"><p>Concatenation</p></th>
<th class="head"><p>Interpolation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Rotation matrix
<img class="math" src="_images/math/7580223f19f8adeaebf264954a214856067e3074.png" alt="\pmb{R}"/></p></td>
<td><p>Transpose</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>Compact axis-angle
<img class="math" src="_images/math/e053af6bf928b8c528cb031ebb9c37ab1b39abc3.png" alt="\pmb{\omega}"/></p></td>
<td><p>Negative</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>(Yes)</p></td>
</tr>
<tr class="row-even"><td><p>Axis-angle
<img class="math" src="_images/math/70583ffeb32a0843b74c661c2ffb65fd2fc0daa1.png" alt="(\hat{\pmb{\omega}}, \theta)"/></p></td>
<td><p>Negative axis</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Logarithm of rotation
<img class="math" src="_images/math/0b9e14c5cc096d7fbff8198de5f08cb44ba42af5.png" alt="\left[\pmb{\omega}\right]"/></p></td>
<td><p>Negative</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>(Yes)</p></td>
</tr>
<tr class="row-even"><td><p>Quaternion
<img class="math" src="_images/math/4093d557bd0321bf32c1cd4263badce666a9d0e2.png" alt="\pmb{q}"/></p></td>
<td><p>Conjugate</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Rotor
<img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/></p></td>
<td><p>Reverse</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Euler angles
<img class="math" src="_images/math/83c71b6e07feeb9e154a6ba4919e7e3455f0e5ed.png" alt="(\alpha, \beta, \gamma)"/></p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
</tbody>
</table>
<div class="section" id="rotation-matrix">
<h2><a class="toc-backref" href="#id1">Rotation Matrix</a><a class="headerlink" href="#rotation-matrix" title="Permalink to this heading">¶</a></h2>
<p>One of the most practical representations of orientation is a rotation matrix</p>
<div class="math">
<p><img src="_images/math/cb15c782df330807e2eeeb7be2b9ee810eae9f11.png" alt="\boldsymbol R =
\left( \begin{array}{ccc}
    r_{11} &amp; r_{12} &amp; r_{13}\\
    r_{21} &amp; r_{22} &amp; r_{23}\\
    r_{31} &amp; r_{32} &amp; r_{33}\\
\end{array} \right)"/></p>
</div><p>Note that</p>
<ul class="simple">
<li><p>this is a non-minimal representation for orientations because we have 9
values but only 3 degrees of freedom</p></li>
<li><p><img class="math" src="_images/math/9b0478c944ec81bbf98d8cb2e9e8ff49466e1f9a.png" alt="\boldsymbol R"/> must be orthonormal</p></li>
<li><p><img class="math" src="_images/math/281193437ad95eb8b4e5588eb17f8b0c57611d79.png" alt="\boldsymbol R^T = \boldsymbol R^{-1}"/></p></li>
<li><p><img class="math" src="_images/math/6daa9be9ce2fce1f2352d4818177fc8a4df785c3.png" alt="det(\boldsymbol R) = 1"/></p></li>
</ul>
<p>pytransform3d uses a numpy array of shape (3, 3) to represent rotation
matrices and typically we use the variable name R for a rotation matrix.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are two conventions on how to interpret rotations: active
or passive rotation. The standard in pytransform3d is an active rotation.
Note that there are some functions to generate rotation matrices that
generate passive rotations as well: <a class="reference internal" href="_apidoc/pytransform3d.rotations.matrix_from_angle.html#pytransform3d.rotations.matrix_from_angle" title="pytransform3d.rotations.matrix_from_angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">matrix_from_angle()</span></code></a>,
<a class="reference internal" href="_apidoc/pytransform3d.rotations.matrix_from_euler_xyz.html#pytransform3d.rotations.matrix_from_euler_xyz" title="pytransform3d.rotations.matrix_from_euler_xyz"><code class="xref py py-func docutils literal notranslate"><span class="pre">matrix_from_euler_xyz()</span></code></a>, and
<a class="reference internal" href="_apidoc/pytransform3d.rotations.matrix_from_euler_zyx.html#pytransform3d.rotations.matrix_from_euler_zyx" title="pytransform3d.rotations.matrix_from_euler_zyx"><code class="xref py py-func docutils literal notranslate"><span class="pre">matrix_from_euler_zyx()</span></code></a>. These are kept
for backward compatibility. When in doubt, read the docstring, which
clearly states that a passive convention is used here.</p>
</div>
<p>We can use a rotation matrix <img class="math" src="_images/math/9ea3b600d91c4a102e2079d6497113822460f9ed.png" alt="\boldsymbol R_{AB}"/> to transform a point
<img class="math" src="_images/math/66590f2c53625eb372136e2bf77aa724fc887458.png" alt="_B\boldsymbol{p}"/> from frame <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> to frame <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are two different conventions on how to use rotation matrices to
apply a rotation to a vector. We can either (pre-)multiply the rotation
matrix to a column vector from the left side or we can (post-)multiply it
to a row vector from the right side.
We will use the <strong>pre-multiplication</strong> convention.</p>
</div>
<p>This means that we rotate a point <img class="math" src="_images/math/66590f2c53625eb372136e2bf77aa724fc887458.png" alt="_B\boldsymbol{p}"/> by</p>
<div class="math">
<p><img src="_images/math/0f3ae92086aab9005716079bcccf60b90242d05d.png" alt="_A\boldsymbol{p} = \boldsymbol{R}_{ABB} \boldsymbol{p}"/></p>
</div><p>This is called <strong>linear map</strong>.</p>
<p>We can see that <em>each column</em> of such a rotation matrix is a basis vector
of frame <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> with respect to frame <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>.</p>
<p>We can plot the basis vectors of an orientation to visualize it.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When plotting basis vectors it is a convention to use red for the x-axis,
green for the y-axis and blue for the z-axis (RGB for xyz).</p>
</div>
<p>Here, we can see orientation represented by the rotation matrix</p>
<div class="math">
<p><img src="_images/math/e91720d98dd90c99b186158afdbe8512b9ab1200.png" alt="\boldsymbol R =
\left( \begin{array}{ccc}
    1 &amp; 0 &amp; 0\\
    0 &amp; 1 &amp; 0\\
    0 &amp; 0 &amp; 1\\
\end{array} \right)"/></p>
</div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytransform3d.rotations</span> <span class="kn">import</span> <span class="n">plot_basis</span>
<span class="n">plot_basis</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//rotations-1.py">Source code</a>, <a class="reference external" href=".//rotations-1.png">png</a>, <a class="reference external" href=".//rotations-1.hires.png">hires.png</a>, <a class="reference external" href=".//rotations-1.pdf">pdf</a>)</p>
<div class="figure align-default">
<img alt="_images/rotations-1.png" class="plot-directive" src="_images/rotations-1.png" />
</div>
<p>We can easily chain multiple rotations: we can apply the rotation defined
by <img class="math" src="_images/math/9ea3b600d91c4a102e2079d6497113822460f9ed.png" alt="\boldsymbol R_{AB}"/> after the rotation <img class="math" src="_images/math/479e6a49216f7964c117c7c6f20334a8789eb239.png" alt="\boldsymbol R_{BC}"/>
by applying the rotation</p>
<div class="math">
<p><img src="_images/math/7de16531e57ecf8c0349877fe60edba4e57fe79b.png" alt="\boldsymbol R_{AC} = \boldsymbol R_{AB} \boldsymbol R_{BC}."/></p>
</div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are two different conventions on how to concatenate rotation
matrices. Suppose we have a rotation matrix <img class="math" src="_images/math/53cf7ab686c88dcddc7745cf2970c2b6de315c7a.png" alt="R_1"/> and another matrix
<img class="math" src="_images/math/f59def0e720f7de8ca2abe4eb16528d1e9b9f3bf.png" alt="R_2"/> and we want to first rotate by <img class="math" src="_images/math/53cf7ab686c88dcddc7745cf2970c2b6de315c7a.png" alt="R_1"/> and then by
<img class="math" src="_images/math/f59def0e720f7de8ca2abe4eb16528d1e9b9f3bf.png" alt="R_2"/>. If we want to apply both rotations in global coordinates, we
have to concatenate them with <img class="math" src="_images/math/5db82d008f7b95daf144bfc3a194f4852765e8fb.png" alt="R_2 \cdot R_1"/>. We can also express
the second rotation in terms of a local, body-fixed coordinates by
<img class="math" src="_images/math/095df9aa7aeebaf66725086d98973784d835f83e.png" alt="R_1 \cdot R_2"/>, which means <img class="math" src="_images/math/53cf7ab686c88dcddc7745cf2970c2b6de315c7a.png" alt="R_1"/> defines new coordinates in
which <img class="math" src="_images/math/f59def0e720f7de8ca2abe4eb16528d1e9b9f3bf.png" alt="R_2"/> is applied. Note that this applies to both
passive and active rotation matrices.</p>
</div>
<p><strong>Pros</strong></p>
<ul class="simple">
<li><p>It is easy to apply rotations on point vectors by matrix-vector
multiplication</p></li>
<li><p>Concatenation of rotations is trivial through matrix multiplication</p></li>
<li><p>You can directly read the basis vectors from the columns</p></li>
<li><p>No singularities</p></li>
</ul>
<p><strong>Cons</strong></p>
<ul class="simple">
<li><p>We use 9 values for 3 degrees of freedom.</p></li>
<li><p>Not every 3x3 matrix is a valid rotation matrix, which means for example
that we cannot simply apply an optimization algorithm to rotation matrices
or interpolate between rotation matrices. Renormalization is
computationally expensive in comparison to quaternions.</p></li>
</ul>
</div>
<div class="section" id="axis-angle">
<h2><a class="toc-backref" href="#id2">Axis-Angle</a><a class="headerlink" href="#axis-angle" title="Permalink to this heading">¶</a></h2>
<p>(<a class="reference external" href="./../../examples/plots/plot_axis_angle.py">Source code</a>, <a class="reference external" href="./../../examples/plots/plot_axis_angle.png">png</a>, <a class="reference external" href="./../../examples/plots/plot_axis_angle.hires.png">hires.png</a>, <a class="reference external" href="./../../examples/plots/plot_axis_angle.pdf">pdf</a>)</p>
<div class="figure align-default">
<img alt="_images/plot_axis_angle.png" class="plot-directive" src="_images/plot_axis_angle.png" />
</div>
<p>Each rotation can be represented by a single rotation around one axis.
The axis can be represented as a three-dimensional unit vector and the angle
by a scalar:</p>
<div class="math">
<p><img src="_images/math/e8e73e5cb22e0fb7685152346668ff54acb27b5a.png" alt="\left( \hat{\boldsymbol{\omega}}, \theta \right) = \left( \left( \begin{array}{c}\omega_x\\\omega_y\\\omega_z\end{array} \right), \theta \right)"/></p>
</div><p>pytransform3d uses a numpy array of shape (4,) for the axis-angle
representation of a rotation, where the first 3 entries correspond to the
unit axis of rotation and the fourth entry to the rotation angle in
radians, and typically we use the variable name a.</p>
<p>It is possible to write this in a more compact way as a rotation vector:</p>
<div class="math">
<p><img src="_images/math/87371eb11bb6564e73fbfff3df178cf7cbfb133d.png" alt="\boldsymbol{\omega} = \theta \hat{\boldsymbol{\omega}}"/></p>
</div><p>pytransform3d uses a numpy array of shape (3,) for the compact axis-angle
representation of a rotation and typically we use the variable name a.</p>
<p>We can also refer to this representation as <strong>exponential coordinates of
rotation</strong>. We can easily represent angular velocity as
<img class="math" src="_images/math/dc594d2afafbfca0a4f1ebafd891120991b9f8e4.png" alt="\dot{\theta} \hat{\boldsymbol{\omega}}"/>
and angular acceleration as
<img class="math" src="_images/math/77a54d4148cbb96fae94f6364d50cc1afac0bdac.png" alt="\ddot{\theta} \hat{\boldsymbol{\omega}}"/> so that we can easily do
component-wise integration and differentiation with this representation.
In addition, we can represent <img class="math" src="_images/math/b5d45663268296cfb65d4e9f6f432fe6a0739785.png" alt="\theta \hat{\boldsymbol{\omega}}"/> by
the cross-product matrix</p>
<div class="math">
<p><img src="_images/math/178feb0b77e77bf67df073966ca2d50b8814401e.png" alt="\left[\hat{\boldsymbol{\omega}}\right] \theta
=
\left(
\begin{matrix}
0 &amp; -\omega_3 &amp; \omega_2\\
\omega_3 &amp; 0 &amp; -\omega_1\\
-\omega_2 &amp; \omega_1 &amp; 0\\
\end{matrix}
\right)
\theta
\in so(3)
\subset \mathbb{R}^{3 \times 3},"/></p>
</div><p>where <img class="math" src="_images/math/df885cda063aa71320c69bb2645e3d4f76c950c4.png" alt="\left[\hat{\boldsymbol{\omega}}\right] \theta"/> is the matrix
logarithm of a rotation matrix and <img class="math" src="_images/math/a0a12b77916dc9989ba20b36a182b3f90fdc3549.png" alt="so(3)"/> is the Lie algebra of
the Lie group <img class="math" src="_images/math/f7f7fa0383c715b76a3ed7b029fd07e2f542451a.png" alt="SO(3)"/>.</p>
<p><strong>Pros</strong></p>
<ul class="simple">
<li><p>Minimal representation (as rotation vector, also referred to as compact axis-angle in the code)</p></li>
<li><p>It is easy to interpret the representation (as axis and angle)</p></li>
<li><p>Can also represent angular velocity and acceleration when we replace
<img class="math" src="_images/math/8a87f04e7d7cca18343c084cceca5237fae62491.png" alt="\theta"/> by <img class="math" src="_images/math/156be057a637fe3140b40c304b4c9a44631b057b.png" alt="\dot{\theta}"/> or <img class="math" src="_images/math/96b8f8a8da08691f9653aa25764e645178573334.png" alt="\ddot{\theta}"/> respectively,
which makes numerical integration and differentiation easy.</p></li>
</ul>
<p><strong>Cons</strong></p>
<ul class="simple">
<li><p>There might be discontinuities during interpolation as an angle of 0 and
any multiple of <img class="math" src="_images/math/2ef04e0a4bcc5f1840308dabe353cfe6e48632c4.png" alt="2\pi"/> represent the same orientation. This has to
be considered.</p></li>
<li><p>Concatenation involves conversion to another representation</p></li>
</ul>
</div>
<div class="section" id="quaternions">
<h2><a class="toc-backref" href="#id3">Quaternions</a><a class="headerlink" href="#quaternions" title="Permalink to this heading">¶</a></h2>
<p>Quaternions are represented by a scalar / real part <img class="math" src="_images/math/cc87ee665749db882f94e0d3707eb23e39638650.png" alt="w"/>
and an vector / imaginary part
<img class="math" src="_images/math/296b7098a4e3f5fcb52474893f620ff2889fb5b6.png" alt="x \boldsymbol{i} + y \boldsymbol{j} + z \boldsymbol{k}"/>.</p>
<div class="math">
<p><img src="_images/math/79e9a168c219f2d86faef761347296ae5ab96899.png" alt="\boldsymbol{q} = w + x \boldsymbol{i} + y \boldsymbol{j} + z \boldsymbol{k}"/></p>
</div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are two different quaternion conventions: Hamilton’s convention
defines <img class="math" src="_images/math/64e011788d9a16919f70050b9abb41dd0d11b27a.png" alt="ijk = -1"/> and the Shuster or JPL convention (from NASA’s
Jet Propulsion Laboratory, JPL) defines <img class="math" src="_images/math/0e435392bb9407c662458c942eabdc96786b4a87.png" alt="ijk = 1"/>.
These two conventions result in different multiplication operations and
conversions to other representations. We use Hamilton’s convention.</p>
</div>
<p>Read <a class="reference external" href="https://arxiv.org/pdf/1801.07478.pdf">this paper</a> for details about
the two conventions and why Hamilton’s convention should be used. Section VI A
gives further useful hints to identify which convention is used.</p>
<p>The unit quaternion space <img class="math" src="_images/math/78a1421a1c9df3cee32686f45ad59741e81f1f6d.png" alt="S^3"/> can be used to represent orientations.
To do that, we use an encoding based on the rotation axis and angle.
A rotation quaternion is a four-dimensional unit vector (versor)
<img class="math" src="_images/math/ccac8697bdb80904a21d231b0f7103543f8001f2.png" alt="\boldsymbol{\hat{q}}"/>.
The following equation describes its relation to axis-axis notation.</p>
<div class="math">
<p><img src="_images/math/1fae510b97e03ea3a554322b0204a078d2f85557.png" alt="\boldsymbol{\hat{q}} =
\left( \begin{array}{c} w\\ x\\ y\\ z\\ \end{array} \right) =
\left( \begin{array}{c}
    \cos \frac{\theta}{2}\\
    \omega_x \sin \frac{\theta}{2}\\
    \omega_y \sin \frac{\theta}{2}\\
    \omega_z \sin \frac{\theta}{2}\\
\end{array} \right)"/></p>
</div><p>pytransform3d uses a numpy array of shape (4,) for quaternions and
typically we use the variable name q.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The scalar component <img class="math" src="_images/math/cc87ee665749db882f94e0d3707eb23e39638650.png" alt="w"/> of a quaternion is sometimes the first
element and sometimes the last element of the versor. We will use
the first element to store the scalar component.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The unit quaternions <img class="math" src="_images/math/ccac8697bdb80904a21d231b0f7103543f8001f2.png" alt="\boldsymbol{\hat{q}}"/> and
<img class="math" src="_images/math/86225c865643a22807d20c325823a7d08846f8b6.png" alt="-\boldsymbol{\hat{q}}"/> represent exactly the same rotation.</p>
</div>
<p><strong>Pros</strong></p>
<ul class="simple">
<li><p>More compact than the matrix representation and less susceptible to
round-off errors</p></li>
<li><p>The quaternion elements vary continuously over the unit sphere in
<img class="math" src="_images/math/1963e1d8fcb281cbc6b8edecfb23c75fd27f06e8.png" alt="\mathbb{R}^4"/> as the orientation changes, avoiding discontinuous
jumps (inherent to three-dimensional parameterizations)</p></li>
<li><p>Expression of the rotation matrix in terms of quaternion parameters
involves no trigonometric functions</p></li>
<li><p>Concatenation is simple and computationally cheaper with the quaternion
product than with rotation matrices</p></li>
<li><p>No singularities</p></li>
<li><p>Renormalization is cheap in comparison to rotation matrices: we only
have to divide by the norm of the quaternion.</p></li>
</ul>
<p><strong>Cons</strong></p>
<ul class="simple">
<li><p>The representation is not straightforward to interpret</p></li>
<li><p>There are always two unit quaternions that represent exactly the same
rotation</p></li>
</ul>
</div>
<div class="section" id="euler-angles">
<h2><a class="toc-backref" href="#id4">Euler Angles</a><a class="headerlink" href="#euler-angles" title="Permalink to this heading">¶</a></h2>
<p>A complete rotation can be split into three rotations around basis vectors.
pytransform3d uses a numpy array of shape (3,) for Euler angles, where
each entry corresponds to a rotation angle in radians around one basis
vector. The basis vector that will be used and the order of rotation
is defined by the convention that we use. See <a class="reference internal" href="euler_angles.html"><span class="doc">Euler Angles</span></a> for more
information.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are 24 different conventions for defining euler angles. There are
12 different valid ways to sequence rotation axes that can be interpreted
as extrinsic or intrinsic rotations: XZX, XYX, YXY, YZY, ZYZ, ZXZ, XZY,
XYZ, YXZ, YZX, ZYX, and ZXY.</p>
</div>
<p><strong>Pros</strong></p>
<ul class="simple">
<li><p>Minimal representation</p></li>
</ul>
<p><strong>Cons</strong></p>
<ul class="simple">
<li><p>24 different conventions</p></li>
<li><p>Singularities (gimbal lock)</p></li>
<li><p>Concatenation and transformation of vectors requires conversion to rotation
matrix or quaternion</p></li>
</ul>
</div>
<div class="section" id="rotors">
<h2><a class="toc-backref" href="#id5">Rotors</a><a class="headerlink" href="#rotors" title="Permalink to this heading">¶</a></h2>
<p>(<a class="reference external" href="./../../examples/plots/plot_bivector.py">Source code</a>, <a class="reference external" href="./../../examples/plots/plot_bivector.png">png</a>, <a class="reference external" href="./../../examples/plots/plot_bivector.hires.png">hires.png</a>, <a class="reference external" href="./../../examples/plots/plot_bivector.pdf">pdf</a>)</p>
<div class="figure align-default">
<img alt="_images/plot_bivector.png" class="plot-directive" src="_images/plot_bivector.png" />
</div>
<p>Rotors and quaternions are very similar concepts in 3D. However, rotors are
more general as they can be extended to more dimensions.</p>
<p>The concept of a quaternion builds on the axis-angle representation, in
which we rotate by an angle about a rotation axis (see black arrow in the
illustration above). The axis can be computed from the cross product of two
vectors (gray arrow). A rotor builds on a plane-angle representation, in which
we rotate with a given direction by an angle in a plane (indicated by gray
area). The plane can be computed from the wedge product <img class="math" src="_images/math/d2d6a29781c70c0393b37d240c9d44075cf0280c.png" alt="a \wedge b"/> of
two vectors <img class="math" src="_images/math/b3e65e3b6408fcfa00452530b73f55d1755f9965.png" alt="a"/> and <img class="math" src="_images/math/68c7c8c65602677ab56cf7fd88002023f0edc575.png" alt="b"/>, which is a so-called bivector. Although
both approaches might seem different, in 3D they operate with exactly the same
numbers in exactly the same way.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The rotors <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> and <img class="math" src="_images/math/c5a3dec6485499140b9ae2662bb4394e68a6ffe6.png" alt="-R"/> represent exactly the same rotation.</p>
</div>
<p>A rotor is a unit multivector</p>
<div class="math">
<p><img src="_images/math/d60c5bf605615cb1044f9657fb36d7e6e3a98ae7.png" alt="R = (a, b_{yz}, b_{zx}, b_{xy})"/></p>
</div><p>that consists of a scalar <img class="math" src="_images/math/b3e65e3b6408fcfa00452530b73f55d1755f9965.png" alt="a"/> and a bivector
<img class="math" src="_images/math/132dab5bff8b770be7a6d3bf0a3ae7bedd01fa4f.png" alt="(b_{yz}, b_{zx}, b_{xy})"/>. The components of a bivector constructed
by the wedge product of two vectors can be interpreted as the area of the
parallelogram formed by the two vectors projected on the three basis planes
yz, zx, and xy (see illustration above). These values also correspond to the
x-, y-, and z-components of the cross product of the two vectors, which allows
two different interpretations of the same numbers from which we can then derive
quaternions on the one hand and rotors on the other hand.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In pytransform3d our convention is that we organize the components of a
rotor in exactly the same way as we organize the components of the
equivalent quaternion. There are other conventions. It is not just possible
to change the order of the scalar and the bivector (similar to a
quaterion), but also to change the order of bivector components.</p>
</div>
<p><strong>Pros</strong></p>
<ul class="simple">
<li><p>More compact than the matrix representation.</p></li>
<li><p>Concatenation is simple and computationally cheaper than with rotation
matrices.</p></li>
<li><p>No singularities.</p></li>
<li><p>Renormalization is cheap in comparison to rotation matrices: we only
have to divide by the norm of the rotor.</p></li>
</ul>
<p><strong>Cons</strong></p>
<ul class="simple">
<li><p>The representation is not straightforward to interpret</p></li>
</ul>
</div>
<div class="section" id="references">
<h2><a class="toc-backref" href="#id6">References</a><a class="headerlink" href="#references" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>Why and How to Avoid the Flipped Quaternion Multiplication: <a class="reference external" href="https://arxiv.org/pdf/1801.07478.pdf">https://arxiv.org/pdf/1801.07478.pdf</a></p></li>
<li><p>Kindr cheat sheet: <a class="reference external" href="https://docs.leggedrobotics.com/kindr/cheatsheet_latest.pdf">https://docs.leggedrobotics.com/kindr/cheatsheet_latest.pdf</a></p></li>
<li><p>Let’s remove Quaternions from every 3D Engine: <a class="reference external" href="https://marctenbosch.com/quaternions/">https://marctenbosch.com/quaternions/</a></p></li>
<li><p>Applications of Geometric Algebra: <a class="reference external" href="http://geometry.mrao.cam.ac.uk/wp-content/uploads/2015/02/01ApplicationsI.pdf">http://geometry.mrao.cam.ac.uk/wp-content/uploads/2015/02/01ApplicationsI.pdf</a></p></li>
<li><p>Euler–Rodrigues formula variations, quaternion conjugation and intrinsic connections: <a class="reference external" href="https://doi.org/10.1016/j.mechmachtheory.2015.03.004">https://doi.org/10.1016/j.mechmachtheory.2015.03.004</a></p></li>
</ul>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014-2022, Alexander Fabisch, DFKI GmbH, Robotics Innovation Center.<br/>
      Last updated on Jun 15, 2022.<br/>
    </p>
  </div>
</footer>
  </body>
</html>